<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤§æ¨¹ç·šä¸Šç™½æ¿</title>
    <style>
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        canvas {
            border: 2px solid #000;
            margin: 10px;
            width: calc(100vw - 30px);
            height: calc(100vh - 30px);
            max-width: 100%;
        }

        .controls-container {
            position: fixed;
            top: 0;
            left: -100%;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background-color: rgba(255,255,255,0.8);
            padding: 20px;
            transition: left 0.3s ease-in-out;
            z-index: 10;
            box-shadow: 2px 0px 10px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .controls label {
            margin-bottom: 5px;
        }

        .controls button {
            margin-top: 5px;
            padding: 5px 15px;
            font-size: 14px;
            background-color: #007BFF;
            color: #fff;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

.controls button.active {
    background-color: #999; /* æˆ–è€…ä»»ä½•ä½ æƒ³è¦çš„ç°è‰²é¡è‰² */
}

        #textInput {
            width: 150px;
        }

#toggleButton {
    position: fixed;
    top: 50%;
    left: -20px; /* é€™å€‹å€¼å¯èƒ½éœ€è¦èª¿æ•´ï¼Œä»¥ä¾¿å®Œæ•´é¡¯ç¤ºæŒ‰éˆ• */
    transform: translateY(-50%);
    z-index: 20;
    background-color: #007BFF;
    color: #fff;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s ease-in-out;
    padding: 10px;
}

        @media (max-width: 768px) {
            #toggleButton {
                top: auto;
                bottom: 20px;
                right: 50%;
                transform: translateX(50%);
            }
        }

        @media (max-width: 576px) {
            #toggleButton {
                bottom: 10px;
            }
        }

        .controls-container.left {
            left: 0;
        }

.using-eraser {
    cursor: crosshair;
}
    </style>
</head>
<body>
    <canvas id="whiteboard"></canvas>
    <button id="toggleButton" onclick="toggleControlsPosition()">â®œ</button>
    <div class="controls-container left">
        <div class="controls">
        <h3>ã€å¤§æ¨¹ç·šä¸Šç™½æ¿åŠŸèƒ½æ¬„ã€‘</h3>
        <label for="shapeSelector">é¸æ“‡ç­†åŠƒå½¢ç‹€ï¼š</label>
<button onclick="changeShape('pen')">ç­†åŠƒ</button>
<button onclick="changeShape('line')">ç›´ç·š</button>
<button onclick="changeShape('rectangle')">çŸ©å½¢</button>
<button onclick="changeShape('circle')">åœ“å½¢</button>
<button onclick="changeShape('arrow')">ç®­é ­</button>
        <select id="shapeSelector" onchange="changeShape(this.value)">
            <option value="pen">ç­†åŠƒ</option>
            <option value="line">ç›´ç·š</option>
            <option value="rectangle">çŸ©å½¢</option>
            <option value="circle">åœ“å½¢</option>
            <option value="arrow">ç®­é ­</option>
        </select>

        <label for="colorPicker">é¸æ“‡é¡è‰²ï¼š</label>
        <input type="color" id="colorPicker" onchange="changeColor(this.value)">
        <label for="sizeSlider">é¸æ“‡ç­†åŠƒå¤§å°ï¼š</label>
        <input type="range" id="sizeSlider" min="1" max="10" value="2" step="1" onchange="changeSize(this.value)">
        <label for="opacitySlider">èª¿æ•´é€æ˜åº¦ï¼š</label>
        <input type="range" id="opacitySlider" min="0" max="1" value="1" step="0.1" onchange="changeOpacity(this.value)">
        <button id="eraserButton" onclick="toggleEraser()">æ©¡çš®æ“¦(é‡è¤‡é»é¸é–‹å•Ÿé—œé–‰)</button>
        <label for="eraserSizeSlider">èª¿æ•´æ©¡çš®æ“¦ç¯„åœå¤§å°ï¼š</label>
        <input type="range" id="eraserSizeSlider" min="5" max="50" value="20" step="1"> 

        <button onclick="clearCanvas()">âœ–å…¨éƒ¨æ¸…é™¤</button>
        <button onclick="undo()">â†ºå¾©åŸ</button>
        <button onclick="redo()">â†»é‡åš</button>        

        <button onclick="addText()">ğ•‹æ·»åŠ æ–‡å­—</button>
        <input type="text" id="textInput" style="display: none;">
                


        <button onclick="saveCanvas()">Öä¿å­˜ç™½æ¿</button>        
        <input type="file" id="imageInput" accept="image/*" onchange="loadImage(event)">

        </div>
    </div>


    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');


        function toggleControlsPosition() {
            const controlsContainer = document.querySelector('.controls-container');
            
            if (controlsContainer.classList.contains('left')) {
                controlsContainer.classList.remove('left');
            } else {
                controlsContainer.classList.add('left');
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth - 30;
            canvas.height = window.innerHeight - 30;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let isDrawing = false;
        let penColor = '#000';
        let penSize = 2;
        let currentShape = 'pen';
        let startX, startY;

        const drawingHistory = [];
        let historyIndex = -1;

        let isErasing = false;
        let eraserSize = 20;
        let opacity = 1;

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawingTouch);
        canvas.addEventListener('touchmove', drawTouch);
        canvas.addEventListener('touchend', stopDrawing);

function startDrawingTouch(event) {
    event.preventDefault();
    const touch = event.touches[0];
    if (isErasing) {
        isDrawing = true;
        erase(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);
    } else {
        isDrawing = true;
        startX = touch.clientX - canvas.offsetLeft;
        startY = touch.clientY - canvas.offsetTop;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        saveState();
    }
}

function drawTouch(event) {
    event.preventDefault();
    const touch = event.touches[0];
    if (!isDrawing) return;
    if (isErasing) {
        erase(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);
    } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(drawingHistory[historyIndex], 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = opacity;
        if (currentShape === 'pen') {
            ctx.lineWidth = penSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = penColor;
            ctx.lineTo(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);
            ctx.stroke();
        } else if (currentShape === 'line' || currentShape === 'rectangle' || currentShape === 'circle') {
            drawShapeTouch(touch);
        }
    }
}

function drawShapeTouch(touch) {
    ctx.lineWidth = penSize;
    ctx.strokeStyle = penColor;

    if (currentShape === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);
        ctx.stroke();
    } else if (currentShape === 'rectangle') {
        ctx.beginPath();
        ctx.rect(startX, startY, touch.clientX - canvas.offsetLeft - startX, touch.clientY - canvas.offsetTop - startY);
        ctx.stroke();
    } else if (currentShape === 'circle') {
        const radius = Math.sqrt(Math.pow(touch.clientX - canvas.offsetLeft - startX, 2) + Math.pow(touch.clientY - canvas.offsetTop - startY, 2));
        ctx.beginPath();
        ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
        ctx.stroke();
    }
}


        function startDrawing(event) {
            if (isErasing) {
                isDrawing = true;
                erase(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
            } else {
                isDrawing = true;
                startX = event.clientX - canvas.offsetLeft;
                startY = event.clientY - canvas.offsetTop;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                saveState();
            }
        }

function draw(event) {
    if (!isDrawing) return;
    if (isErasing) {
        erase(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
    } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(drawingHistory[historyIndex], 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = opacity;

        if (currentShape === 'pen') {
            ctx.lineWidth = penSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = penColor;
            ctx.lineTo(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
            ctx.stroke();
        } else if (currentShape === 'line' || currentShape === 'rectangle' || currentShape === 'circle') {
            drawShape(event);
        } else if (currentShape === 'arrow') {
            drawArrow(event);
        }
    }
}

        function drawShape(event) {
            ctx.lineWidth = penSize;
            ctx.strokeStyle = penColor;

            if (currentShape === 'line') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
                ctx.stroke();
            } else if (currentShape === 'rectangle') {
                ctx.beginPath();
                ctx.rect(startX, startY, event.clientX - canvas.offsetLeft - startX, event.clientY - canvas.offsetTop - startY);
                ctx.stroke();
            } else if (currentShape === 'circle') {
                const radius = Math.sqrt(Math.pow(event.clientX - canvas.offsetLeft - startX, 2) + Math.pow(event.clientY - canvas.offsetTop - startY, 2));
                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }

        function erase(x, y) {
            const radius = eraserSize / 2;
            ctx.clearRect(x - radius, y - radius, eraserSize, eraserSize);
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
                ctx.closePath();
            }
        }

        function changeColor(color) {
            penColor = color;
        }

        function changeSize(size) {
            penSize = size;
        }

        function changeShape(shape) {
            currentShape = shape;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveState();
        }

        function saveCanvas() {
            const fileName = 'whiteboard';
            const imageFormat = 'png';
            const image = canvas.toDataURL(`image/${imageFormat}`);
            const link = document.createElement('a');
            link.href = image;
            link.download = `${fileName}.${imageFormat}`;
            link.click();
        }

        function addText() {
            textInput.style.display = 'block';
            textInput.focus();
        }

        textInput.addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                ctx.font = '20px Arial';
                ctx.fillStyle = penColor;
                ctx.fillText(textInput.value, startX, startY);
                textInput.value = '';
                textInput.style.display = 'none';
                saveState();
            }
        });

function toggleEraser() {
    isErasing = !isErasing;

    const eraserButton = document.getElementById('eraserButton'); // å–å¾—æ©¡çš®æ“¦æŒ‰éˆ•å…ƒç´ 

    if (isErasing) {
        canvas.classList.add('using-eraser');
        eraserButton.classList.add('active'); // æ·»åŠ  active é¡åˆ¥
    } else {
        canvas.classList.remove('using-eraser');
        eraserButton.classList.remove('active'); // ç§»é™¤ active é¡åˆ¥
    }
}

        function changeOpacity(value) {
            opacity = value;
        }

        function loadImage(event) {
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                saveState();
            };
            img.src = URL.createObjectURL(event.target.files[0]);
        }

        function saveState() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            drawingHistory.splice(historyIndex + 1);
            drawingHistory.push(imageData);
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(drawingHistory[historyIndex], 0, 0);
            }
        }

        function redo() {
            if (historyIndex < drawingHistory.length - 1) {
                historyIndex++;
                ctx.putImageData(drawingHistory[historyIndex], 0, 0);
            }
        }

        const eraserSizeSlider = document.getElementById('eraserSizeSlider');
        eraserSizeSlider.addEventListener('change', function () {
            eraserSize = parseInt(eraserSizeSlider.value);
        });

function changeShape(shape) {
    currentShape = shape;
}

function drawArrow(event) {
    if (currentShape === 'arrow') {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(drawingHistory[historyIndex], 0, 0);
        ctx.lineWidth = penSize;
        ctx.strokeStyle = penColor;

        // Calculate arrow parameters
        const endX = event.clientX - canvas.offsetLeft;
        const endY = event.clientY - canvas.offsetTop;
        const arrowLength = 3 * penSize;  // å°‡ç®­é ­çš„é•·åº¦è¨­ç‚ºç­†åŠƒå¤§å°çš„ä¸‰å€
        const angle = Math.atan2(endY - startY, endX - startX);

        // Calculate points for the triangle
        const triangleBaseMidX = endX - arrowLength * Math.cos(angle);
        const triangleBaseMidY = endY - arrowLength * Math.sin(angle);
        const triangleLeftX = triangleBaseMidX + penSize * Math.sin(angle);
        const triangleLeftY = triangleBaseMidY - penSize * Math.cos(angle);
        const triangleRightX = triangleBaseMidX - penSize * Math.sin(angle);
        const triangleRightY = triangleBaseMidY + penSize * Math.cos(angle);

        // Draw arrow line excluding the head
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(triangleBaseMidX, triangleBaseMidY);
        ctx.stroke();

        // Draw the triangle arrowhead
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(triangleLeftX, triangleLeftY);
        ctx.lineTo(triangleRightX, triangleRightY);
        ctx.closePath();
        ctx.fill();
    }
}

    </script>
</body>
</html>
